/*
FLUJO COMPLETO DE UNA META FINANCIERA:

1. Usuario crea meta
   â†“
   POST /api/goals
   {
     name: "Viaje a JapÃ³n",
     targetAmount: 2000000,
     deadline: "2026-06-30",
     category: "Viajes"
   }
   â†“
2. Se guarda en tabla goals:
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ id: 1                                      â”‚
   â”‚ user_id: 1                                 â”‚
   â”‚ name: Viaje a JapÃ³n                        â”‚
   â”‚ target_amount: 2000000.00                  â”‚
   â”‚ deadline: 2026-06-30                       â”‚
   â”‚ category: Viajes                           â”‚
   â”‚ status: active                             â”‚
   â”‚ created_at: 2025-10-08T15:30:00Z           â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â†“
3. Usuario va ahorrando (crea transacciones):
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Transaction 1: +$500,000 (Viajes)        â”‚
   â”‚ Transaction 2: +$300,000 (Viajes)        â”‚
   â”‚ Transaction 3: +$200,000 (Viajes)        â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â†“
4. Dashboard calcula progreso dinÃ¡micamente:
   GET /api/goals/1
   
   goal.calculateProgress() â†’
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ currentAmount: 1000000                   â”‚
   â”‚ targetAmount: 2000000                    â”‚
   â”‚ remaining: 1000000                       â”‚
   â”‚ percentage: 50.00%                       â”‚
   â”‚ isCompleted: false                       â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   
   goal.getDaysRemaining() â†’ 265 dÃ­as
   goal.isNearDeadline() â†’ false
   goal.isOverdue() â†’ false
   â†“
5. Usuario sigue ahorrando...
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Transaction 4: +$1,000,000 (Viajes)      â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â†“
6. Sistema verifica automÃ¡ticamente:
   Goal.checkAndCompleteGoals(userId)
   
   progress.isCompleted = true â†’ âœ…
   goal.markAsCompleted()
   
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ status: active â†’ completed                 â”‚
   â”‚ updated_at: 2025-12-15T10:00:00Z           â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â†“
7. Usuario recibe notificaciÃ³n:
   "ğŸ‰ Â¡Felicidades! Alcanzaste tu meta 'Viaje a JapÃ³n'"

CASOS ESPECIALES:

- Meta sin deadline:
  deadline: null
  getDaysRemaining() â†’ null (sin lÃ­mite de tiempo)
  
- Meta pausada:
  goal.pause() â†’ status = 'paused'
  No aparece en metas activas
  
- Meta cancelada:
  goal.cancel() â†’ status = 'cancelled'
  Se mantiene en historial pero no se muestra
  
- Meta vencida:
  deadline pasÃ³ pero no se completÃ³
  isOverdue() â†’ true
  Mostrar alerta: "âš ï¸ Esta meta venciÃ³ hace X dÃ­as"
*/

// ============================================
// MODELO: GOAL (Metas Financieras)
// ============================================
const { DataTypes } = require('sequelize');
const sequelize = require('../config/database');

const Goal = sequelize.define('Goal', {
    // ==================== COLUMNAS ====================

    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true,
        comment: 'ID Ãºnico de la meta'
    },

    userId: {
        type: DataTypes.INTEGER,
        allowNull: false,
        field: 'user_id',
        references: {
            model: 'users',
            key: 'id'
        },
        onDelete: 'CASCADE',
        comment: 'ID del usuario dueÃ±o de la meta'
    },

    name: {
        type: DataTypes.STRING(100),
        allowNull: false,
        validate: {
            notEmpty: {
                msg: 'El nombre de la meta no puede estar vacÃ­o'
            },
            len: {
                args: [3, 100],
                msg: 'El nombre debe tener entre 3 y 100 caracteres'
            }
        },
        comment: 'Nombre descriptivo de la meta'
    },

    targetAmount: {
        type: DataTypes.DECIMAL(15, 2),
        allowNull: false,
        field: 'target_amount',
        validate: {
            min: {
                args: [0.01],
                msg: 'El monto objetivo debe ser mayor a 0'
            },
            isDecimal: {
                msg: 'El monto debe ser un nÃºmero vÃ¡lido'
            }
        },
        comment: 'Monto objetivo a alcanzar'
    },

    // NOTA: current_amount se CALCULA dinÃ¡micamente, NO se guarda en BD
    // Esto evita inconsistencias con las transacciones

    deadline: {
        type: DataTypes.DATEONLY,
        allowNull: true,
        validate: {
            isDate: {
                msg: 'Debe ser una fecha vÃ¡lida'
            },
            isFutureDate(value) {
                if (value && new Date(value) < new Date()) {
                    throw new Error('La fecha lÃ­mite debe ser futura');
                }
            }
        },
        comment: 'Fecha lÃ­mite para alcanzar la meta (opcional)'
    },

    category: {
        type: DataTypes.STRING(50),
        allowNull: true,
        comment: 'CategorÃ­a asociada a la meta (ej: Viaje, Auto, Casa)'
    },

    status: {
        type: DataTypes.ENUM('active', 'paused', 'completed', 'cancelled'),
        allowNull: false,
        defaultValue: 'active',
        validate: {
            isIn: {
                args: [['active', 'paused', 'completed', 'cancelled']],
                msg: 'El estado debe ser: active, paused, completed o cancelled'
            }
        },
        comment: 'Estado de la meta'
    },

    description: {
        type: DataTypes.TEXT,
        allowNull: true,
        validate: {
            len: {
                args: [0, 500],
                msg: 'La descripciÃ³n no puede exceder 500 caracteres'
            }
        },
        comment: 'DescripciÃ³n opcional de la meta'
    }

}, {
    // ==================== OPCIONES ====================

    sequelize,
    modelName: 'Goal',
    tableName: 'goals',
    timestamps: true,
    underscored: true,

    // ==================== ÃNDICES ====================

    indexes: [
        {
            fields: ['user_id']
        },
        {
            fields: ['status']
        },
        {
            fields: ['deadline']
        },
        {
            fields: ['user_id', 'status']  // Ãndice compuesto
        }
    ]
});

// ==================== MÃ‰TODOS DE INSTANCIA ====================

// Calcular progreso actual de la meta
Goal.prototype.calculateProgress = async function () {
    const Transaction = require('./Transaction');
    const { Op } = require('sequelize');

    // Si la meta tiene categorÃ­a especÃ­fica, solo contar transacciones de esa categorÃ­a
    const whereClause = {
        userId: this.userId,
        type: 'income',
        isActive: true
    };

    if (this.category) {
        whereClause.category = this.category;
    }

    const currentAmount = await Transaction.sum('amount', {
        where: whereClause
    }) || 0;

    const percentage = (currentAmount / this.targetAmount) * 100;
    const remaining = this.targetAmount - currentAmount;

    return {
        currentAmount: parseFloat(currentAmount.toFixed(2)),
        targetAmount: parseFloat(this.targetAmount),
        remaining: parseFloat(remaining.toFixed(2)),
        percentage: parseFloat(percentage.toFixed(2)),
        isCompleted: currentAmount >= this.targetAmount
    };
};

// Obtener dÃ­as restantes hasta la fecha lÃ­mite
Goal.prototype.getDaysRemaining = function () {
    if (!this.deadline) {
        return null;
    }

    const today = new Date();
    const deadline = new Date(this.deadline);
    const diffTime = deadline - today;
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

    return diffDays;
};

// Verificar si la meta estÃ¡ vencida
Goal.prototype.isOverdue = function () {
    if (!this.deadline) {
        return false;
    }

    return new Date() > new Date(this.deadline) && this.status !== 'completed';
};

// Verificar si estÃ¡ prÃ³xima a vencer (menos de 7 dÃ­as)
Goal.prototype.isNearDeadline = function () {
    const daysRemaining = this.getDaysRemaining();
    return daysRemaining !== null && daysRemaining <= 7 && daysRemaining > 0;
};

// Marcar meta como completada
Goal.prototype.markAsCompleted = async function () {
    this.status = 'completed';
    await this.save();
};

// Pausar meta
Goal.prototype.pause = async function () {
    this.status = 'paused';
    await this.save();
};

// Reactivar meta
Goal.prototype.activate = async function () {
    this.status = 'active';
    await this.save();
};

// Cancelar meta
Goal.prototype.cancel = async function () {
    this.status = 'cancelled';
    await this.save();
};

// Obtener informaciÃ³n completa (con progreso)
Goal.prototype.getFullInfo = async function () {
    const progress = await this.calculateProgress();
    const daysRemaining = this.getDaysRemaining();

    return {
        id: this.id,
        name: this.name,
        description: this.description,
        targetAmount: this.targetAmount,
        category: this.category,
        deadline: this.deadline,
        status: this.status,
        progress,
        daysRemaining,
        isOverdue: this.isOverdue(),
        isNearDeadline: this.isNearDeadline(),
        createdAt: this.createdAt,
        updatedAt: this.updatedAt
    };
};

// ==================== MÃ‰TODOS ESTÃTICOS ====================

// Obtener todas las metas activas de un usuario
Goal.getActiveGoals = async function (userId) {
    return await this.findAll({
        where: {
            userId,
            status: 'active'
        },
        order: [['deadline', 'ASC NULLS LAST']]  // Ordenar por deadline, nulls al final
    });
};

// Obtener metas con progreso completo
Goal.getGoalsWithProgress = async function (userId) {
    const goals = await this.findAll({
        where: { userId },
        order: [['createdAt', 'DESC']]
    });

    const goalsWithProgress = await Promise.all(
        goals.map(async (goal) => await goal.getFullInfo())
    );

    return goalsWithProgress;
};

// Obtener metas prÃ³ximas a vencer
Goal.getNearDeadlineGoals = async function (userId) {
    const { Op } = require('sequelize');
    const sevenDaysFromNow = new Date();
    sevenDaysFromNow.setDate(sevenDaysFromNow.getDate() + 7);

    return await this.findAll({
        where: {
            userId,
            status: 'active',
            deadline: {
                [Op.between]: [new Date(), sevenDaysFromNow]
            }
        },
        order: [['deadline', 'ASC']]
    });
};

// Obtener metas vencidas
Goal.getOverdueGoals = async function (userId) {
    const { Op } = require('sequelize');

    return await this.findAll({
        where: {
            userId,
            status: 'active',
            deadline: {
                [Op.lt]: new Date()
            }
        },
        order: [['deadline', 'ASC']]
    });
};

// Obtener metas completadas
Goal.getCompletedGoals = async function (userId) {
    return await this.findAll({
        where: {
            userId,
            status: 'completed'
        },
        order: [['updatedAt', 'DESC']]
    });
};

// Verificar automÃ¡ticamente metas completadas
Goal.checkAndCompleteGoals = async function (userId) {
    const activeGoals = await this.getActiveGoals(userId);
    const completedGoals = [];

    for (const goal of activeGoals) {
        const progress = await goal.calculateProgress();

        if (progress.isCompleted) {
            await goal.markAsCompleted();
            completedGoals.push(goal);
        }
    }

    return completedGoals;
};

module.exports = Goal;